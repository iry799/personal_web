<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>

        // 1.思考如下代码的运行结果，通过实验进行验证，同时思考最后一段代码结果的原因。
        let a1, b1, c1 = [1, 2, 3, ]; 
        console.log(a1, b1,c1);//undefined undefined [1,2,3]
        
        let [a2, b2, c2] = [1,2,3,]; 
        console.log(a2, b2, c2);//1 2 3

        let [a3,b3, c3] =[1, , 3,]; 
        console.log(a3, b3, c3);//1 undefined 3

        let [a4, b4] = [1];
        console.log(a4, b4);//1 undefined

        let { y: a5, b5 } = { x: 1, y: 2 }; 
        console.log(a5,b5);//2 undefined
        //这里是对象解构，将 { x: 1, y: 2 } 对象中的 y 属性赋值给 a5，但对象中没有 b5 属性，所以 b5 是 undefined。

        let { a6,b6} = 123; 
        console.log(a6, b6);//undefined undefined
        //这里试图从 123 中解构出 a6 和 b6，但 123 是一个基本类型的数字，并不是对象，因此无法进行解构。


        // 2.运行如下代码，写出实验结果。
        console.log("第二题")

        let set = new Set();
        set.add(1);
        set.add(2);
        set.add(3);
        set.delete(2);
        let i = set.values();
        console.log(i.next());//{value: 1, done: false}
        console.log(i.next());//{value: 3, done: false}
        console.log(i.next());//{value: undefined, done: true}
        // i.next() 方法会返回一个对象，这个对象有两个属性：value 和 done。
        // value 表示当前迭代位置的值。
        // done 表示是否已经迭代完所有元素。

        //3、运行以下代码，写出为什么最后一段代码没有输出任何结果的原因
        console.log("第三题")
        let map = new Map();
        map.set(1, "a");
        map.set(2, "b");
        map.set(3, "c");
        map.set(4, "d");
        for (let i = 1; i <= map.size; i++) {
            console.log(map.get(i));
        }
        map.forEach(function (value, key) {
            console.log(value);
        });

        for (let v of map.values()) {
            console.log(v);
        }
        for (var prop in map) {
            console.log(prop);
        }
        // for...in 遍历 Map，但是 for...in 遍历的是对象的属性，而不是 Map 的键值对。因此这个循环并不会输出 Map 中的键值对


        //4、运行如下代码，验证运行结果，并简要阐述原因.
        console.log("第四题")
        let arr1 = [1, 2, 3];
        let arr2 = arr1;
        console.log(arr1 == arr2);//true
        //JavaScript 中的对象（包括数组）赋值时是按引用赋值的，所以 arr1 和 arr2 实际上指向同一个数组。
        let arr3 = [...arr1];
        console.log(arr1 == arr3);//false
        // 这里使用了扩展运算符 [...arr1]，它会创建 arr1 的一个浅拷贝，生成了一个新的数组 arr3。


        //5、用箭头函数改写如下代码，写出改写后的代码并运行验证
        // let arr4 =[1,2,3];
        // arr4.forEach(function(v,k){
        // console.log(v);
        // })
        //改写后
        console.log("第五题")
        let arr4 = [1, 2, 3];
        arr4.forEach((v, k) => {
        console.log(v);//1，2，3
        });


        //运行如下代码，写出这两句代码的作用
        console.log("第六题")
        Array.of(1,2,3).filter(i =>i>1).forEach(i => console.log(i));//2，3
        //Array.of(1, 2, 3) 创建一个数组 [1, 2, 3]。
        //.filter(i => i > 1) 对数组进行过滤，只保留大于 1 的元素。这里会保留 2 和 3。
        //.forEach(i => console.log(i)) 对过滤后的数组进行遍历，将每个元素输出到控制台。
        let fib=n=>n>1?fib(n-1)+fib(n-2):n;//定义了一个递归的斐波那契数列函数。当大于1时返回fib(n-1)+fib(n-2)，小于等于1时返回n本身

        //使用class和extends实现继承关系
        console.log("第七题")
        class Animal {//父类
            constructor(name){//构造函数
                this.name=name;
            }
            shount(){
                console.log(`${this.name}`);
            }
        }
        class Dog extends Animal {//子类继承父类
            constructor(name,age){
                super(name);
                this.age=age;
            }
            eat(){
                console.log(`${this.name}哒哒哒`);
            }
        }
        let dog = new Dog('旺旺',3);
        console.log(dog);
        dog.shount();
        dog.eat();

    </script>
</body>

</html>